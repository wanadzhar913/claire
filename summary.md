### Claire backend — end-to-end flow (what we did and what happens)

### 1) Running the backend with Docker Compose
- **Command**: `docker compose up --build`
- **What it does**:
  - Builds images for services that have `build:` (notably **`api`** and **`db`**)
  - Starts containers and wires **ports**, **networks**, **env vars**, **volumes**
- **Services involved**:
  - **Postgres (`db`)**: runs on `localhost:5432` and initializes schema (first run) from `postgres/init.sql`
  - **MinIO (`minio`)**: object store on `localhost:9000` (console `localhost:9001`)
  - **Bucket bootstrap (`createbuckets`)**: creates the MinIO bucket and user/policy
  - **FastAPI (`api`)**: runs on `localhost:8000`

### 2) Fixes required to get the stack running
- **CRLF vs LF issue in `scripts/create-bucket.sh`**:
  - The `createbuckets` container was failing with `set: - invalid option` due to Windows line endings.
  - Converting the script line endings to **LF** fixed it.
- **`api` not starting**:
  - Initially, the `api` service was commented out in `docker-compose.yaml`, so `localhost:8000` refused connections.
  - Uncommenting the `api` service allowed FastAPI to start and expose Swagger docs at `http://localhost:8000/docs`.

### 3) What the Swagger page is
- `http://localhost:8000/docs` is the **OpenAPI/Swagger UI** generated by FastAPI.
- It lists all available endpoints and lets you click **Try it out** to send real requests and see responses/curl commands.

### 4) User creation (needed for uploads)
- The upload endpoint uses a simple “auth” mechanism:
  - You pass **`user_email`** as a query parameter.
  - The backend looks up the user in Postgres and derives `user_id`.
- **Endpoint used**: `POST /api/v1/users/register`
- **Result**: a new row in `app_users`, returning `id`, `email`, `created_at`.

### 5) Uploading a PDF statement (the main pipeline)
- **Endpoint used**: `POST /api/v1/file-uploads/upload`
- **Request**:
  - `multipart/form-data` with a `file` field (your PDF bytes)
  - Query params like `user_email=...` and `statement_type=banking_transaction`
  - Optional `expense_month` / `expense_year` (defaults to current month/year if not provided)

### 6) What happens inside `POST /file-uploads/upload`
The endpoint is **synchronous** (it only returns when all steps finish):
- **Step A — Read file bytes**:
  - FastAPI reads the uploaded file into `file_content` and measures `file_size`.
- **Step B — Store the raw PDF in MinIO**:
  - Uploads to MinIO at path like `users/<user_id>/<file_id>` (bucket = `MINIO_BUCKET_NAME`)
  - Returns a **presigned URL** (valid for ~7 days) stored in the DB as `file_url`
- **Step C — Create a `user_upload` DB record**:
  - Inserts metadata into Postgres table `user_upload` with the generated `file_id`
- **Step D — Extract transactions** (only when `statement_type=banking_transaction`):
  - Calls the document extractor which uses OpenAI (default backend):
    - It base64-encodes the file bytes and sends them to OpenAI for structured extraction
  - Transforms extracted results into `BankingTransaction` models
  - Bulk inserts rows into `statement_banking_transaction`
- **Response**:
  - Returns `file_id`, `file_name`, `file_size`, `file_url`, `statement_type`, `transactions_extracted`, and a success message

### 7) Why uploads can “take a long time”
- The upload endpoint waits for OpenAI extraction + DB inserts before responding.
- For many PDFs, the **OpenAI call is the slowest step**, so Swagger looks like it’s “loading forever” until the request completes.

### 8) Querying extracted transactions
- **Endpoint used**: `GET /api/v1/query/transactions`
- You can filter by:
  - `file_id` (exact match)
  - `transaction_year`, `transaction_month`
  - date ranges, amount ranges, merchant name, category, etc.
- Important gotcha:
  - A previous query returned `[]` because the `file_id` had an extra encoded quote (`%22`) at the end.
  - The DB filter is exact (`WHERE file_id = ...`), so any extra character yields no rows.

### 9) What the transaction JSON output means
- The response (like in `example.json`) is a list of rows from `statement_banking_transaction`:
  - **`file_id`** ties each transaction to the uploaded statement (`user_upload.file_id`)
  - **`transaction_date` + year/month/day** enables month-based queries (e.g., December 2025)
  - **`transaction_type`** (`debit`/`credit`) enables cashflow summaries
  - **`category`** enables breakdowns (subscriptions, food, groceries, etc.)
  - **`created_at`** shows when the row was written to Postgres

### 10) Duplicate monthly statements (desired behavior)
- Desired behavior: if a user uploads “December” again, the newest should win and the old should become inactive.
- Current schema + endpoints do **not** enforce “only one active upload per month” yet.
- Recommended approach:
  - Add an “active/invalidated” flag to `user_upload`
  - Enforce one active record per `(user_id, statement_type, expense_year, expense_month)`
  - Ensure queries/calculations only include the active upload